<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<meta charset="utf-8"/>
<meta name="description" content="Paleomagnetism.org: An open source tool for paleomagnetic analysis">
<meta name="keywords" content="Paleomagnetism, Palaeomagnetism, Statistics, Analysis, Javascript, Magnetic, Zijderveld">
<meta name="author" content="Paleomagnetism.org">

<!-- Supporting Libraries -->
<link href="./src/libs/ui/jquery-ui.css" rel="stylesheet"> <!-- jQuery UI stylesheet -->

<link href="./css/paldir.css" type="text/css" rel="stylesheet" /> <!-- paleomagnetism.org stylesheet -->
<link href="./css/pMagJS.css" type="text/css" rel="stylesheet" /> <!-- paleomagnetism.org stylesheet -->

<link href="./src/libs/notiny-master/src/notiny.css" rel="stylesheet"> <!-- Notification style sheet (Notiny) -->
<script src="./src/libs/jquery-1.11.1.js"></script> <!-- jQuery -->
<script src="./src/libs/ui/jquery-ui.js"></script> <!-- jQuery UI -->
<script src="./src/libs/notiny-master/src/notiny.js"></script> <!-- (notiny) notification plugin -->
<script src="./src/libs/highcharts2.src.js"></script> <!-- Highcharts Main -->
<script src="./src/libs/highcharts-more.src.js"></script> <!-- Highcharts plugin for extra graphs -->
<script src="./src/libs/heatmap.src.js"></script> <!-- HighCharts HeatMap Plugin -->
<script src="./src/libs/exporting.src.js"></script> <!-- Highcharts figure exporting -->
<script src="./src/libs/numeric-1.2.6.js"></script> <!-- Numeric JS to calculate principle components -->
<script src="./src/libs/jquery.multiselect.js"></script> <!-- jQuery plugin for multiselect -->

<script src="./src/core.js"></script> <!-- jQuery plugin for multiselect -->

<link rel="shortcut icon" type="image/x-icon" href="icon.ico" />
<title> Paleomagnetism.org - Oroclinal Test </title>

<style>

input {
	text-align: center;
}

</style>
<script>

/* PALEOMAGNETISM.ORG 
 * 
 * NTR Analysis
 * Last Update: 7/17/2015
 * Description: calculates original dyke orientations based on site magnetization vector and reference magnetization vector
 */

isRunning = false;
 
 //Fire on DOM ready
$(function() {

	$("button:not(.ui-multiselect)").button()
    .bind('mouseup', function() {
        $(this).blur();   
	});
	
   $( "#iterationBar" ).progressbar();
  
	$("#tabs").tabs();

	$("#initializeNTR, #iterationButton").button().click( function (event) {
	
		if(isRunning) {
			notify('failure', 'NTR Analysis is already running. Please wait');
			return;
		}
		
		isRunning = true;
		
		//Definition of known vectors
		//referencePole = Known Reference Pole
		//magnetizationVector = Site Remanent Magnetization Vector
		//dykePole = Pole to Dyke Orientation
		var referencePole = {
			dec: Number($("#refPoleDec").val()), 
			inc: Number($("#refPoleInc").val())
		};
		
		var magnetizationVector = {
			dec: Number($("#magDec").val()), 
			inc: Number($("#magInc").val())
		};
		
		var dykePole = {
			dec: Number($("#dykeDec").val()),
			inc: Number($("#dykeInc").val())
		};
	
		if(event.target.id == 'initializeNTR') {
			NTRAnalysis(referencePole, magnetizationVector, dykePole, false, 'initialPlot');
			$("#interationDiv").show();
		} else if ( event.target.id == 'iterationButton') {
			NTRAnalysis(referencePole, magnetizationVector, dykePole, true, 'iterationPlot');
		}
		
	});
	

});

/* FUNCTION ellipseEndpoints
 * Description: finds maximum/maximum endpoints on ellipse for calculation of confidence interval
 *            : function has been condensed (see fn ellipseData for comments)
 */
 var ellipseEndpoints = function(mDec, mInc, dDx, dIx, color) {
 
	var correctApproach = !$('#incorrect').prop('checked');
	
	var dDx = dDx*rad;
	var dIx = dIx*rad;
	
	var incSign = (Math.abs(mInc)/mInc); // 1 or -1 depending on inclination polarity
	
	if(mInc == 0) {
		incSign = 1;
	}
	
	var xDec = mDec;
	var xInc = mInc;
	var yDec = mDec;
	var yInc = (mInc-(incSign*90));
	var zDec = (mDec+90);
	var zInc = 0;
	discreteEllipsePoints = [];
	
	//Number of points; this time we want to find the 4 points evenly spaced around the mean vector
	//Therefore we take 0, 90, 180, and 270 degrees.
	var nPoints = [0, Math.PI/2, Math.PI, 3*Math.PI/2];

	//Same routine as usual (condensed)
	R = [[0,0,0],[0,0,0],[0,0,0]];
	var X = cart(xDec, xInc);
	if(X.z < 0) {
		X.x = -X.x
		X.y = -X.y
		X.z = -X.z
	}
	R[0][0]=X.x;
	R[1][0]=X.y;
	R[2][0]=X.z;
	var Y = cart(yDec,yInc);
	if(Y.z < 0) {
		Y.x = -Y.x
		Y.y = -Y.y
		Y.z = -Y.z
	}
	R[0][1]=Y.x;
	R[1][1]=Y.y;
	R[2][1]=Y.z;
	var Z = cart(zDec, zInc);
	if(Z.z < 0) {
		Z.x = -Z.x
		Z.y = -Z.y
		Z.z = -Z.z
	}
	R[0][2]=Z.x;
	R[1][2]=Z.y;
	R[2][2]=Z.z;
	v = [0,0,0];

	for(i=0;i< nPoints.length;i++){
		v[1] = Math.sin(dIx)*Math.cos(nPoints[i]);
		v[2] = Math.sin(dDx)*Math.sin(nPoints[i]);
		v[0] = Math.sqrt( 1 - Math.pow(v[1],2) - Math.pow(v[2],2) ); //resulting coordinate on unit-sphere.
		eli = [0,0,0];
		for(var j=0;j<3;j++){
			for(var k=0;k<3;k++){ 
				eli[j]=eli[j] + R[j][k]*v[k];
			}
		}
		
		var coords = new dir(eli[0], eli[1], eli[2]);

		if(incSign < 0) {
			coords.dec = (180+coords.dec)%360;
			coords.inc = -coords.inc;
		}
		
		if(coords.inc < 0) {
			var fillColor = 'white';
		} else {
			var fillColor = color;
		}
		
		if(correctApproach) {
			discreteEllipsePoints.push({
				x: coords.dec, 
				y: eqArea(coords.inc), 
				inc: coords.inc, 
				marker: { 
					fillColor: fillColor,
					lineWidth: 1,
					lineColor: color,
				}
			});
		}
	}
	
	//I'm having issues with the NTR Analysis program. It appears to take dec + confidence as an endpoint on the ellipse which is not true.
	//This gives a false representation of the real confidence.
	if(!correctApproach) {
		discreteEllipsePoints.push({x: mDec+dDx/rad, y: eqArea(mInc), inc: mInc});
		discreteEllipsePoints.push({x: mDec-dDx/rad, y: eqArea(mInc), inc: mInc});
		discreteEllipsePoints.push({x: mDec, y: eqArea(mInc+dIx/rad), inc: mInc+dIx/rad});
		discreteEllipsePoints.push({x: mDec, y: eqArea(mInc-dIx/rad), inc: mInc-dIx/rad});
	}	
			
	return discreteEllipsePoints;
}

/* FUNCTION ellipseDataZero
 * Description: finds two points on an ellipse that are closest to inclination 01//EN
 *            : function has been condensed
 * Input: Mean vector and confidence envelope
 * Output: Object containing two vectors that represent intersections with the horizontal
 */
var ellipseDataZero = function(mDec, mInc, dDx, dIx) {
		
		var dDx = dDx*rad;
		var dIx = dIx*rad;
		
		var incSign = (Math.abs(mInc)/mInc); // 1 or -1 depending on inclination polarity
		
		if(mInc == 0) {
			incSign = 1;
		}
		
		var xDec = mDec
		var xInc = mInc
		var yDec = mDec
		var yInc = (mInc-(incSign*90))
		var zDec = (mDec+90)
		var zInc = 0

		discreteEllipsePoints = [];

		//Number of points, go for 10000 iterations
		//That should be sufficiently close to the horizontal
		var nPoints = 10000;
		var iPoint = (nPoints/2);

		R = [[0,0,0],[0,0,0],[0,0,0]];
		var X = cart(xDec, xInc); //new z-coordinate
		
		if(X.z < 0) {
	
			X.x = -X.x
			X.y = -X.y
			X.z = -X.z
		}

		R[0][0]=X.x;
		R[1][0]=X.y;
		R[2][0]=X.z;
		var Y = cart(yDec,yInc); //new y-coordinate
		if(Y.z < 0) {
			Y.x = -Y.x
			Y.y = -Y.y
			Y.z = -Y.z
		}
		R[0][1]=Y.x;
		R[1][1]=Y.y;
		R[2][1]=Y.z;
		var Z = cart(zDec, zInc); //new x-coordinate
		 if(Z.z < 0) {
			Z.x = -Z.x
			Z.y = -Z.y
			Z.z = -Z.z
		}
		R[0][2]=Z.x;
		R[1][2]=Z.y;
		R[2][2]=Z.z;
		v = [0,0,0];
		for(i=0;i<nPoints;i++){
			psi = ((i)*Math.PI/iPoint);
			v[1] = Math.sin(dIx)*Math.cos(psi);
			v[2] = Math.sin(dDx)*Math.sin(psi);
			v[0] = Math.sqrt( 1 - Math.pow(v[1],2) - Math.pow(v[2],2) ); //resulting coordinate on unit-sphere.

			eli = [0,0,0];
			for(var j=0;j<3;j++){
				for(var k=0;k<3;k++){ 
					eli[j]=eli[j] + R[j][k]*v[k];
				}
			}
			var coords = new dir(eli[0], eli[1], eli[2]);
			
			if(incSign < 0) {
				coords.dec = (coords.dec+180)%360;
			}
			
			if(coords.inc > 0) {
				discreteEllipsePoints.push({x: coords.dec, y: eqArea(coords.inc), inc: coords.inc});
			}	
		}
	
	//The way the ellipse is drawn we find the minimum inclination at the centre of the discreteEllipsePoints array
	//There is some degree of uncertainty but it decreases with the number of iterations (N=1000)

	var index = parseInt(discreteEllipsePoints.length/2);

	var intercept = {
		one: {
			dec: discreteEllipsePoints[index].x, 
			inc: discreteEllipsePoints[index].inc
		}, 
		two: {
			dec: discreteEllipsePoints[index+1].x, 
			inc: discreteEllipsePoints[index+1].inc
		}
	};
	
	return intercept;
	
}

/* FUNCTION bisectorPlane
 * Description: finds the bisector plane between two vectors
 *            : the pole of the bisector is equal to v1 - v2.
 * Input: two vectors
 * Output: plane data to be plotted, and the position of the pole to this plane
 */
function bisectorPlane( one, two ) {

	var cart1 = cart(one.dec, one.inc);
	var cart2 = cart(two.dec, two.inc);

	var pole = new dir(cart1.x-cart2.x, cart1.y-cart2.y, cart1.z-cart2.z);
	
	return {
		data: getPlaneData({dec: pole.dec, inc: pole.inc}, 'GC'), 
		pole: pole
	}
}

/* FUNCTION getIntersection
 * Description: finds the line of intersection between two planes
 * Input: poles to given planes
 * Output: direction of the intersection
 */ 
function getIntersection( pole1, pole2 ) {
	
	//Get the pole directions in Cartesian coordinates
	var cart1 = cart(pole1.dec, pole1.inc);
	var cart2 = cart(pole2.dec, pole2.inc);
	
	//Get the cross product of the two vectors
	var cross = getCross(cart1, cart2);
	
	//Return the direction of the perpendicular vector (which is the line of intersection between the planes)
	return new dir(cross.x, cross.y, cross.z);
}

/* FUNCTION getCross
 * Description: calculates the cross product for two vectors
 * Input: two vectors in Cartesian coordinates
 * Output: cross product in Cartesian coordinates
 */
function getCross ( cart1, cart2 ) {
	return {
		x: (cart1.y*cart2.z - cart2.y*cart1.z),
		y: (-cart1.x*cart2.z + cart2.x*cart1.z),
		z: (cart1.x*cart2.y - cart2.x*cart1.y)
	}		
}

/* FUNCTION NTRAnalysis
 * Calculates rotation parameters to bring observed magnetization vector to reference direction and dyke pole to horizontal
 * Input: NULL
 * Output: VOID (draws graph and fills table)
 */
function NTRAnalysis (referencePole, magnetizationVector, dykePole, iterate, container) {
	
	//If iterate, we need confidence envelopes and calculate 125 permutations that we wish to compared
	if(iterate) {
	
		//Parameters to determine confidence ellipses on the three specified vector
		//This is equal to the 95% confidence interval
		var referencePoleInc95 = Number($("#confRef").val());
		var magnetizationVectorDec95 = Number($("#confMagDec").val());
		var magnetizationVectorInc95 = Number($("#confMagInc").val());
		var dykePole95 = Number($("#confDyke").val());
		
		//Calculation of confidence ellipses and four maximum/minimum endpoints for each ellipse
		var referencePoleEndPoints = ellipseEndpoints(referencePole.dec, referencePole.inc, 0, referencePoleInc95, 'rgb(191, 119, 152)');
		
		var ellipseParameters = {
			'xDec' 	: referencePole.dec,
			'xInc'	: referencePole.inc,
			'yDec'	: referencePole.dec,
			'yInc'	: referencePole.inc - 90,
			'zDec'	: referencePole.dec + 90,
			'zInc'	: 0,
			'beta'	: 0,
			'gamma'	: referencePoleInc95
		}
		
		var referencePoleEllipse = new ellipseData(ellipseParameters, false);
		referencePoleEndPoints.push({x: referencePole.dec, y: eqArea(referencePole.inc), inc: referencePole.inc});
		
		var magnetizationVectorEndPoints = ellipseEndpoints(magnetizationVector.dec, magnetizationVector.inc, magnetizationVectorDec95, magnetizationVectorInc95, 'rgb(119, 191, 152)');
		
		var ellipseParameters = {
			'xDec' 	: magnetizationVector.dec,
			'xInc'	: magnetizationVector.inc,
			'yDec'	: magnetizationVector.dec,
			'yInc'	: magnetizationVector.inc - 90,
			'zDec'	: magnetizationVector.dec + 90,
			'zInc'	: 0,
			'beta'	: magnetizationVectorDec95,
			'gamma'	: magnetizationVectorInc95
		}
		var magnetizationVectorEllipse = new ellipseData(ellipseParameters, false);
		
		magnetizationVectorEndPoints.push({x: magnetizationVector.dec, y: eqArea(magnetizationVector.inc), inc: magnetizationVector.inc});
		
		var dykePoleEndPoints = ellipseEndpoints(dykePole.dec, dykePole.inc, dykePole95, dykePole95, 'orange');
		var ellipseParameters = {
			'xDec' 	: dykePole.dec,
			'xInc'	: dykePole.inc,
			'yDec'	: dykePole.dec,
			'yInc'	: dykePole.inc - 90,
			'zDec'	: dykePole.dec + 90,
			'zInc'	: 0,
			'beta'	: dykePole95,
			'gamma'	: dykePole95
		}
		var dykePoleEllipse = new ellipseData(ellipseParameters, false);
		dykePoleEndPoints.push({x: dykePole.dec, y: eqArea(dykePole.inc), inc: dykePole.inc});
		
		var iterationPermutations = [];

		//Calculate 125 iterations for points on confidence envelopes
		for(var i = 0; i < referencePoleEndPoints.length; i++) {
			for(var j = 0; j < magnetizationVectorEndPoints.length; j++) {
				for(var k = 0; k < dykePoleEndPoints.length; k++) {
					iterationPermutations.push([
						[
							referencePoleEndPoints[i].x, 
							referencePoleEndPoints[i].inc
						], [
							magnetizationVectorEndPoints[j].x,
							magnetizationVectorEndPoints[j].inc
						], [
							dykePoleEndPoints[k].x,
							dykePoleEndPoints[k].inc,
						]
					]);
				}
			}
		}		
		
		var intersectionArray1 = [];
		var intersectionArray2 = [];
	
	//Not iterating, just take the given directions (single permutation)
	} else {
		iterationPermutations = [[[referencePole.dec, referencePole.inc], [magnetizationVector.dec, magnetizationVector.inc], [dykePole.dec, dykePole.inc]]];
	}
	
	var i = 0;
	var bar = $("#iterationBar");
	
	//Asynchronous implementation of iterations
	function timed() {
	
		//Update progress bar
		bar.progressbar('value', (i/((iterationPermutations.length)-1)*100));

		//For one iteration, get the appropriate directions
		var referencePole = {
			dec: iterationPermutations[i][0][0],
			inc: iterationPermutations[i][0][1]
		}
		var magnetizationVector = {
			dec: iterationPermutations[i][1][0],
			inc: iterationPermutations[i][1][1]
		}
		var dykePole = {
			dec: iterationPermutations[i][2][0],
			inc: iterationPermutations[i][2][1]		
		}
		
		//Obtain angle beta between dyke pole and site magnetization vector (ChRM)
		//This angle should remain constant
		var beta = angle(dykePole.dec, dykePole.inc, magnetizationVector.dec, magnetizationVector.inc);

		//Beta cannot go over 90; if so, we flip the dykePole too
		if(beta > 90) {
			beta = 180-beta;
			dykePole.inc = -dykePole.inc;
			dykePole.dec = (dykePole.dec+180)%360;
			console.log('Beta exceeds 90 degrees; dyke pole has been flipped.');
		}
		
		//Draw small circle around the reference pole with angle beta
		var ellipseParameters = {
			'xDec' 	: referencePole.dec,
			'xInc'	: referencePole.inc,
			'yDec'	: referencePole.dec,
			'yInc'	: referencePole.inc - 90,
			'zDec'	: referencePole.dec + 90,
			'zInc'	: 0,
			'beta'	: beta,
			'gamma'	: beta
		}
		
		var sCircle = new ellipseData(ellipseParameters, false);

		//Numerically iterate over same small circle to find declinations that are closest to 0
		//I cannot think of a proper analytical implementation - suggestions?
		var intercept = new ellipseDataZero(referencePole.dec, referencePole.inc, beta, beta, false);
				
		//Get bisector plane for the following vector pairs:
		//1. magnetizationVector - referencePole
		//2. dykePole - iCept1
		//3. dykePole - iCept2
		var k = bisectorPlane(magnetizationVector, referencePole);
		var l = bisectorPlane(dykePole, intercept.one);
		var m = bisectorPlane(dykePole, intercept.two);

		//Now we want to find the two intersections of the three bisectors
		//1. Intersection between magnetizationVector - referencePole and dykePole - iCept1
		//2. Intersection between magnetizationVector - referencePole and dykePole - iCept2
		//These are interceps 1 and 2 and represent the two rotation axes of our solutions
		var intS = getIntersection(k.pole, l.pole);
		var intS2 = getIntersection(k.pole, m.pole);
		
		//Get the angle between the planes (NTR Analysis prints this information so we might as well)
		var anglePlane1 = angle(k.pole.dec, k.pole.inc, l.pole.dec, l.pole.inc);
		var anglePlane2 = angle(k.pole.dec, k.pole.inc, m.pole.dec, m.pole.inc);
	
		//Believe the convention is to make rotation poles positive
		if(intS.inc < 0) {
			intS.inc = -intS.inc;
			intS.dec = (intS.dec + 180)%360;
		}
		if(intS2.inc < 0) {
			intS2.inc = -intS2.inc;
			intS2.dec = (intS2.dec + 180)%360;
		}
		
		//Find the vectors perpendicular to the rotation axes and compare the angle
		//The angle of rotation is equal to the angle between the cross products of the vectors
		var m1 = getIntersection(intS, magnetizationVector);
		var m2 = getIntersection(intS, referencePole);
		var angle1 = angle(m1.dec, m1.inc, m2.dec, m2.inc);
		
		//Calculate cross product between m1 and m2 to find sense of rotation (positive is CCW; negative is CW)
		var cross = getIntersection(m1, m2);
		if(cart(cross.dec, cross.inc).z < 0) {
			var type1 = 'CW';	
		} else {
			var type1 = 'CCW';
		}
		
		//Repeat procedure for second intersection
		var m1 = getIntersection(intS2, magnetizationVector);
		var m2 = getIntersection(intS2, referencePole);
		var angle2 = angle(m1.dec, m1.inc, m2.dec, m2.inc);
		
		var cross = getIntersection(m1, m2);
		if(cart(cross.dec, cross.inc).z < 0) {
			var type2 = 'CW';	
		} else {
			var type2 = 'CCW';
		}
		
		//If we're doing multiple iterations, save the rotation axes for display
		if(iterate) {
			intersectionArray1.push({
				'x': intS.dec, 
				'y': eqArea(intS.inc), 
				'inc': intS.inc, 
				'rotation': angle1, 
				'rotationSense': type1,
				'dykeStrike': ((intercept.one.dec+90)%360).toFixed(1),
				'dykeDip': (90-intercept.one.inc).toFixed(1)
			});
			intersectionArray2.push({
				'x': intS2.dec, 
				'y': eqArea(intS2.inc), 
				'inc': intS2.inc, 
				'rotation': angle2, 
				'rotationSense': type2,
				'dykeStrike': ((intercept.two.dec+90)%360).toFixed(1),
				'dykeDip': (90-intercept.two.inc).toFixed(1)
			});
		};
		
		//One iteration completed
		i++;	
	
		//If we haven't done all permutations, do more
		if(i < iterationPermutations.length) {
			setTimeout(function() { timed(); }, 5);
			
		//Escape the timed routine
		} else {
							
			if(!iterate) {
				//Update table with found information
				$("#NTRInputTable").html('<table class="sample" style="text-align: center"> <thead> <tr> <th> Reference Vector </th> <th> Site Vector </th> <th> Pole to Dyke </th> <th> Beta </th> </tr> </thead> <tbody> <tr> <td> <b> Declination </b>' + referencePole.dec.toFixed(1) + '<br> <b> Inclination </b>' + referencePole.inc.toFixed(1) + ' </td> <td> <b> Declination </b>' + magnetizationVector.dec.toFixed(1) + '<br> <b> Inclination </b>' + magnetizationVector.inc.toFixed(1) + ' </td> <td> <b> Declination </b>' + dykePole.dec.toFixed(1) + '<br> <b> Inclination </b>' + dykePole.inc.toFixed(1) + ' </td> <td> ' + beta.toFixed(1) + ' </td> </tr> </tbody> </table>').show(); 
				$("#NTRSolutionTable").html('<table class="sample" style="text-align: center"> <thead> <tr> <th> Solution 1 - Rotation Pole </th> <th>Solution 2 - Rotation Pole </th>  </tr> </thead> <tbody> <tr> <td> <b> Declination </b>' + intS.dec.toFixed(1) + '<br> <b> Inclination </b>' + intS.inc.toFixed(1) + '<br> <b> Angle of Rotation </b> ' + angle1.toFixed(1) + ' <br> <b> Sense of Rotation </b> ' + type1 + ' <br> <b> Angle Between Planes </b> ' + anglePlane1.toFixed(1) + ' <hr> <b> Initial Dyke Strike </b> ' + ((intercept.one.dec+90)%360).toFixed(1) +  ' <br> <b> Initial Dyke Dip </b> ' + (90-intercept.one.inc).toFixed(1) + '</td> <td> <b> Declination </b>' + intS2.dec.toFixed(1) + '<br> <b> Inclination </b>' + intS2.inc.toFixed(1) + '<br> <b> Angle of Rotation </b> ' + angle2.toFixed(1) + ' <br>  <b> Sense of Rotation </b> ' + type2 + ' <br> <b> Angle Between Planes </b> ' + anglePlane2.toFixed(1) + ' <hr> <b> Initial Dyke Strike </b> ' + ((intercept.two.dec+90)%360).toFixed(1) +  ' <br> <b> Initial Dyke Dip </b> ' + (90-intercept.two.inc).toFixed(1) + ' </td> </tr> </table>').show();
			}
	
		//Do the proper positive/negative color scheme for vectors
		var referenceColor = 'rgb(191, 119, 152)';
		if(referencePole.inc < 0) {
			referenceColor = 'white';
		}
		
		var dykeColor = 'orange';
		if(dykePole.inc < 0) {
			var dykeColor = 'white';
		}
		
		var chrmColor = 'rgb(119, 191, 152)';
		if(magnetizationVector.inc < 0) {
			var chrmColor = 'white';
		}
			
		//Construct plotSeries
		//Be warned these are many
		plotSeries = [];
	
		//If we do not wish to iterate, show the appropriate bisectors/intersections for the actual specified directions
		if(!iterate) {
			plotSeries.push({
			name: 'Reference Pole',
			type: 'scatter',
			data: [{x: referencePole.dec, y: eqArea(referencePole.inc), inc: referencePole.inc}],
			marker: {
				symbol: 'circle',
				fillColor: referenceColor,
				lineWidth: 1,
				lineColor: 'rgb(191, 119, 152)',
			}
		}, {
			name: 'Pole to Dyke',
			type: 'scatter',
			data: [{x: dykePole.dec, y: eqArea(dykePole.inc), inc: dykePole.inc}],
			marker: {
				symbol: 'circle',
				fillColor: dykeColor,
				lineColor: 'orange',
				lineWidth: 1,
			}
		}, {
			name: 'Magnetization Vector',
			type: 'scatter',
			data: [{x: magnetizationVector.dec, y: eqArea(magnetizationVector.inc), inc: magnetizationVector.inc}],
			marker: {
				symbol: 'circle',
				fillColor: chrmColor,
				lineColor: 'rgb(119, 191, 152)',
				lineWidth: 1,
			}
		}, {
				name: 'Beta',
				type: 'line',
				turboThreshold: 0,
				data: sCircle.pos,
				color: 'grey',
				dashStyle: 'ShortDash',
				enableMouseTracking: false,
				lineWidth: 1,
				marker: {
					enabled: false	
				}
			}, {
				name: 'Intersections (numerical)',
				type: 'scatter',
				color: 'rgb(119, 152, 191)',
				marker: {
					symbol: 'circle',
				},
				data: [{x: intercept.one.dec, y: eqArea(intercept.one.inc), inc: intercept.one.inc}, {x: intercept.two.dec, y: eqArea(intercept.two.inc), inc: intercept.two.inc}]
			}, {
				name: 'Bisector [Site - Reference]',
				type: 'line',
				color: 'red',
				dashStyle: 'ShortDash',
				enableMouseTracking: false,
				lineWidth: 1,
				marker: {
					enabled: false
				},
				data: k.data.one
			}, {
				name: 'Site - Reference',
				linkedTo: ':previous',
				type: 'line',
				color: 'red',
				lineWidth: 1,
				enableMouseTracking: false,
				marker: {
					enabled: false
				},
				data: k.data.two
			}, {
				name: 'Bisector [#1 - Dyke Pole]',
				type: 'line',
				enableMouseTracking: false,
				color: 'blue',
				lineWidth: 1,
				marker: {
					enabled: false
				},
				data: m.data.two
			}, {
				name: 'Bisector [#1 - Dyke Pole]',
				type: 'line',
				linkedTo: ':previous',
				color: 'blue',
				dashStyle: 'ShortDash',
				enableMouseTracking: false,
				lineWidth: 1,
				marker: {
					enabled: false
				},
				data: m.data.one
			},{
				name: 'Bisector [#2 - Dyke Pole]',
				type: 'line',
				color: 'green',
				enableMouseTracking: false,
				lineWidth: 1,
				marker: {
					enabled: false
				},
				data: l.data.two
			},{
				name: 'Bisector [#2 - Dyke Pole]',
				type: 'line',
				dashStyle: 'ShortDash',
				color: 'green',
				lineWidth: 1,
				linkedTo: ':previous',
				enableMouseTracking: false,
				marker: {
					enabled: false
				},
				data: l.data.one
			},{
				name: 'Solution 1 - Rotation Pole',
				type: 'scatter',
				data: [{x: intS.dec, y: eqArea(intS.inc), inc: intS.inc}],
				marker: {
					symbol: 'circle'
				}
			},{
				name: 'Solution 2 - Rotation Pole',
				type: 'scatter',
				data: [{x: intS2.dec, y: eqArea(intS2.inc), inc: intS2.inc}],
				marker: {
					symbol: 'circle'
				}
			});
		}
		
		//If the user wishes to iterate over the confidence intervals, show these intervals on the graph
		if(iterate) {
			plotSeries.push({
				name: 'a95 Magnetization Vector',
				type: 'line',
				id: 'a95MagPole',
				enableMouseTracking: false,
				data: magnetizationVectorEllipse.neg,
				lineWidth: 1,
				color: 'rgb(119, 191, 152)',
				marker: {
					enabled: false
				}	
			}, {
				name: 'a95 Magnetization Vector',
				linkedTo: 'a95MagPole',
				type: 'line',
				enableMouseTracking: false,
				color: 'rgb(119, 191, 152)',
				data: magnetizationVectorEllipse.pos,
				lineWidth: 1,
				marker: {
					enabled: false
				}	
			}, {
				name: 'a95 Magnetization Vector',
				type: 'scatter',
				linkedTo: 'a95MagPole',
				data: magnetizationVectorEndPoints,
				color: 'rgb(119, 191, 152)',
				marker: {
					symbol: 'circle',
					radius: 4,
				}
			}, {
				name: 'a95 Dyke Pole',
				type: 'line',
				id: 'a95DykePole',
				enableMouseTracking: false,
				data: dykePoleEllipse.neg,
				lineWidth: 1,
				color: 'orange',
				marker: {
					enabled: false
				}	
			}, {
				name: 'a95 Dyke Pole',
				linkedTo: 'a95DykePole',
				type: 'line',
				color: 'orange',
				enableMouseTracking: false,
				data: dykePoleEllipse.pos,
				lineWidth: 1,
				marker: {
					enabled: false
				}	
			}, {
				name: 'a95 Dyke Pole',
				type: 'scatter',
				linkedTo: 'a95DykePole',
				data: dykePoleEndPoints,
				color: 'orange',
				marker: {
					symbol: 'circle',
					radius: 4,
				}
			}, {
				name: 'a95 Reference Pole',
				type: 'line',
				id: 'a95ReferencePole',
				enableMouseTracking: false,
				data: referencePoleEllipse.neg,
				lineWidth: 1,
				color: 'rgb(191, 119, 152)',
				marker: {
					enabled: false
				}	
			}, {
				name: 'a95 Reference Pole',
				linkedTo: 'a95ReferencePole',
				type: 'line',
				enableMouseTracking: false,
				data: referencePoleEllipse.pos,
				color: 'rgb(191, 119, 152)',
				lineWidth: 1,
				marker: {
					enabled: false
				}	
			}, {
				name: 'a95 Reference Pole',
				type: 'scatter',
				linkedTo: 'a95ReferencePole',
				data: referencePoleEndPoints,
				color: 'rgb(191, 119, 152)',			
				marker: {
					symbol: 'circle',
					radius: 4,
				}
			}, {
				name: 'Solution 1 (Confidence Interval)',
				type: 'scatter',
				color: 'rgb(119, 152, 191)',
				data: intersectionArray1,
				marker: {
					symbol: 'circle',
					radius: 4,
				}
			}, {
				name: 'Solution 2 (Confidence Interval)',
				type: 'scatter',
				color: 'rgb(191, 119, 152)',
				data: intersectionArray2,
				marker: {
					symbol: 'circle',
					radius: 4,
				}
			})
		}
		
		//Call plotting series
		drawGraph(plotSeries, container);
		isRunning = false;
			}
		}
	
	//Call initial timed function once
	timed();
}

function drawGraph( plotSeries, container ) {

	//Specify chart options for equal area projection
	var chartOptions = {
		chart: {
			backgroundColor: 'rgba(255, 255, 255, 0)',
			id: container,
			polar: true,
			animation: false,
        	renderTo: container, //Container that the chart is rendered to.
		},
		tooltip: {
			borderColor: 'rgb(119, 152, 191)',
		},
		title: {
            text: 'Net Tectonic Rotation Analysis',
			style: { 
				fontSize: '32px'
			}
        },
        subtitle: {
			text: ' Solutions for initial dyke orientations ',
        },
      	pane: {
			startAngle: 0,
			endAngle: 360
     	},
		yAxis: {
			type: 'linear',
			reversed: true,
			labels: {
				enabled: false
			},
			tickInterval: 90,
      	    min: 0,
			max: 90,
        },
		tooltip: {
			formatter: function() {
				if(this.series.name == 'Solution 1 (Confidence Interval)' || this.series.name == 'Solution 2 (Confidence Interval)') {
					return '<b>Name:</b> ' + this.series.name + '<br><b>Declatinion:</b> ' + this.x.toFixed(1) + '<br><b>Inclination:</b> ' + this.point.inc.toFixed(1) + '<br><b>Rotation:</b> ' + this.point.rotation.toFixed(1) + ' ' + this.point.rotationSense + '<br><b>Initial Dyke Strike:</b> ' + this.point.dykeStrike + '<br><b>Initial Dyke Dip:</b> ' + this.point.dykeDip
				} else {
					return '<b>Name:</b> ' + this.series.name + '<br><b>Declatinion:</b> ' + this.x.toFixed(1) + '<br><b>Inclination:</b> ' + this.point.inc.toFixed(1)
				}
			}
		},
		exporting: { 
			enabled: true,
            sourceWidth: 800,
			filename: 'NTR',
            sourceHeight: 800,
            buttons: {
                contextButton: {
                    symbolStroke: '#7798BF',
					align: 'right'
                }
            }
        },
		credits: {
			enabled: true,
			text: "Paleomagnetism.org (NTR Analysis)",
			href: ''
		},
        xAxis: {
			minorTickPosition: 'inside',
			type: 'linear',
			min: 0,
			max: 360,
            minorGridLineWidth: 0,
            tickPositions: [0, 90, 180, 270, 360],
            minorTickInterval: 10,
            minorTickLength: 5,
            minorTickWidth: 1,
            labels: {
                formatter: function () {
                    return this.value + '\u00B0'; //Add degree symbol to x-axis labels.
                }
            }
        },
        plotOptions: {
			series: {
				animation: false,
			}
       	 },

    		series: plotSeries,
	};

	chartFoldLeft = new Highcharts.Chart(chartOptions); //Initialize chart with specified options.
	$("#"+container).show();
}
/* FUNCTION getPlaneData
 * Description: calculates discrete points about a pole (dirIn)
 *            : either type GC (plane) or MAD (ellipse)
 * Input: direction: vector, type: plane or MAD (angle required)
 * Output: returns data containing discrete points on a plane
 */
function getPlaneData ( dirIn, type, MAD, signInc ) {

	var mDec = dirIn.dec
	var mInc = dirIn.inc
	
	if(signInc != undefined) {
		if(signInc < 0) {
			mDec += 180;
		}
	}
	
	var mySeries = [];
	var mySeries2 = [];
	
	var incSign = (Math.abs(mInc)/mInc); // 1 or -1 depending on inclination polarity
	
	if(mInc == 0) {
		incSign = 1;
	}
	
	//Axis one (mean direction)
	var xDec = mDec
	var xInc = mInc
	
	//Axis two (add or substract 90 degrees to the inclination)
	var yDec = mDec
	var yInc = (mInc-(incSign*90))

	//Axis three (add 90 degrees to the declination)
	var zDec = (mDec+90)
	var zInc = 0
			
	var nPoints = 501;
	
	var iPoint = ((nPoints-1)/2);
	
	R = [[0,0,0],[0,0,0],[0,0,0]];

	/*
 	 * Cartesian coordinates and construct rotation matrix Rij 
 	 */
	var X = cart(xDec, xInc); //new z-coordinate
	
	if(X.z < 0) {
		X.x = -X.x
		X.y = -X.y
		X.z = -X.z
	}

	R[0][0]=X.x;
	R[1][0]=X.y;
	R[2][0]=X.z;

	var Y = cart(yDec,yInc); //new y-coordinate

	if(Y.z < 0) {
		Y.x = -Y.x
		Y.y = -Y.y
		Y.z = -Y.z
	}
	
	R[0][1]=Y.x;
	R[1][1]=Y.y;
	R[2][1]=Y.z;
	
	var Z = cart(zDec, zInc); //new x-coordinate

	 if(Z.z < 0) {
		Z.x = -Z.x
		Z.y = -Z.y
		Z.z = -Z.z
	}
	
	R[0][2]=Z.x;
	R[1][2]=Z.y;
	R[2][2]=Z.z;

	// column vector v containing coordinates of the ellipse before rotation in world coordinates
 	// psi is incremented along a circle from 0 to 2pi in n points with radius defined by a95
	// the resulting vector contains the ellipse position in local coordinates.
	// X is mapped on R-coordinates of v

	v = [0,0,0];
	var doOnce = true;
	var doOnce2 = true;
	
	for(i=0; i<nPoints; i++){

		psi = ((i)*Math.PI/iPoint);
		
		if(type == 'GC') {
			v[1] = Math.cos(psi);
			v[2] = Math.sin(psi);
			v[0] = 0 //resulting coordinate on unit-sphere.
		} else if (type == 'MAD') {
			v[1] = Math.sin(MAD*rad)*Math.cos(psi);
			v[2] = Math.sin(MAD*rad)*Math.sin(psi);
			v[0] = Math.sqrt( 1 - Math.pow(v[1],2) - Math.pow(v[2],2) ); //resulting coordinate on unit-sphere.
		}

 		// Matrix multiplication V'j = RijVj		
		eli = [0,0,0];
		for(var j=0;j<3;j++){
			for(var k=0;k<3;k++){ 
				eli[j]=eli[j] + R[j][k]*v[k];
			}
		}

		// Convert Cartesian coordinates of ellipse back to declination/inclination.
		var coords = new dir(eli[0], eli[1], eli[2]);
		
		if(incSign < 0) {
			coords.dec = (coords.dec+180)%360;
		}
		
		if(eli[2] < 0) {
			if(type == 'MAD') {
				coords.dec = (coords.dec+180)%360;
			}
			if(doOnce) {
				mySeries2.push({x: null, y: null});
				doOnce = !doOnce;
			}
			mySeries.push({x: coords.dec, y: eqArea(coords.inc), inc: coords.inc});
		} else {
			if(doOnce2) {
				mySeries.push({x: null, y: null});
				doOnce2 = !doOnce2;
			}
			mySeries2.push({x: coords.dec, y: eqArea(coords.inc), inc: coords.inc});
		}	

	}
	return {one: mySeries, two: mySeries2};
}

/* FUNCTION getCSV
 * Description: custom function to parse Highcharts data to csv format on exporting
 * Input: triggered by clicking export CSV -> passes chart ID
 * Output: CSV formatted variable that can be downloaded through dlItem routine
 */
(function (Highcharts) {

     downloadAttrSupported = document.createElement('a').download !== undefined;
		
    // Options
    var itemDelimiter = '","';
    var lineDelimiter = '\n';

	//Add a prototype function
    Highcharts.Chart.prototype.getCSV = function () {
		
		var csv = "";
	
		/*
		 * CSV EXPORTING: Site means (Figure 2)
		 */
		 
		 if(this.userOptions.chart.id === 'initialPlot') {
			notify('failure', 'Exporting empty file - not implemented.');
		 } 
		 
		 //Plot for iteration
		 if(this.userOptions.chart.id === 'iterationPlot') {
		 	
			var columns = ['Solution 1'];	
			csv += '"' + columns.join(itemDelimiter) + '"' + lineDelimiter;
			var columns = ['Declination', 'Inclination', 'Rotation', 'Sense', 'Dyke Orientation'];	
			csv += '"' + columns.join(itemDelimiter) + '"' + lineDelimiter;
			
			for(var i = 0; i < this.series[9].data.length; i++) {
				var columns = [this.series[9].data[i].x, this.series[9].data[i].inc, this.series[9].data[i].rotation, this.series[9].data[i].rotationSense, this.series[9].data[i].dykeStrike];	
				csv += '"' + columns.join(itemDelimiter) + '"' + lineDelimiter;
			}
			
			csv += lineDelimiter;
			
			var columns = ['Solution 2'];	
			csv += '"' + columns.join(itemDelimiter) + '"' + lineDelimiter;
			var columns = ['Declination', 'Inclination', 'Rotation', 'Sense', 'Dyke Orientation'];	
			csv += '"' + columns.join(itemDelimiter) + '"' + lineDelimiter;	
			
			for(var i = 0; i < this.series[10].data.length; i++) {
				var columns = [this.series[10].data[i].x, this.series[10].data[i].inc, this.series[10].data[i].rotation, this.series[10].data[i].rotationSense, this.series[10].data[i].dykeStrike];	
				csv += '"' + columns.join(itemDelimiter) + '"' + lineDelimiter;
			}	
		 }

		return csv;
		
    };  
	
}(Highcharts));

// Now we want to add "Download CSV" to the exporting menu.
// Code changed after https://github.com/highslide-software/export-csv
// Original Author: Torstein Honsi (Highcharts)
Highcharts.getOptions().exporting.buttons.contextButton.menuItems.push({

    text: 'Download CSV file',
    onclick: function () {
	
		//Parse data to CSV format
		var csv = this.getCSV(); 
		
		//Download the parsed CSV
		dlItem(csv, 'csv');
	}
});

/* FUNCTION dlItem
 * Description: creates a BLOB that can be downloaded
 * Input: string to be downloaded (usually a csv-formatted string), and extension for the file
 * Output: VOID
 */
function dlItem ( string, extension ) {
	
	//Check if supported
	downloadAttrSupported = document.createElement('a').download !== undefined;
	
	var blob = new Blob([string], { type: 'data:text/csv;charset=utf-8,'});
	var csvUrl = URL.createObjectURL(blob);
	var name = 'export';

		// Download attribute supported
        if (downloadAttrSupported) {
            a = document.createElement('a');
            a.href = csvUrl;
            a.target      = '_blank';
            a.download    = name + '.' + extension;
            document.body.appendChild(a);
            a.click();
            a.remove();
		} else if (window.Blob && window.navigator.msSaveOrOpenBlob) {
			// Falls to msSaveOrOpenBlob if download attribute is not supported
			window.navigator.msSaveOrOpenBlob(blob, name + '.' + extension);
		} else {
			// Fall back to server side handling (Highcharts)
			Highcharts.post('http://www.highcharts.com/studies/csv-export/download.php', {
				data: string,
				type: 'txt',
				extension: extension
		});
	}
}
</script>
</HEAD>

<BODY>
<div id="body_container" style="text-align: justify;">

	<!-- HEADER -->
	<div id="title" style="margin: 0 auto; padding: 5px; background-color: #fff">
		<div style="display: inline-block; padding-right: 10px;">
			<img style="margin: 0px; height: 60px;" src="./images/icon.png">
		</div>
	</div>
	
	<!-- MENU CONTACT -->
	<div style="background-color: #7798BF; color: white; padding: 10px;"></div>
	
		<div id="tabs">
			<ul>
				<li><a href="#NTRTab" title="General information"> NTR Analysis </a></li>
				<li><a href="#optionsTab" title="General information">  Advanced Options </a></li>
			</ul>
			
			<!-- Tab for NTR Analysis -->
			<div id="NTRTab" style="text-align: center;">
				<h2> Net Tectonic Rotation Analysis <small> blablablabla </small> </h2>
				<div style="margin: 0 auto; width: 800px; border: 1px dotted rgb(119, 152, 191);">
					<table class="sample" style="text-align: center;"> 
						<thead> 
							<th> Reference Pole </th> 
							<th> Magnetization Vector </th> 
							<th> Pole to Dyke </th>
						</thead>
						<tbody>
							<td>
								<b> Dec: </b> <input type="text" size="5" id="refPoleDec">
								<br><b> Inc: </b> <input type="text" size="5" id="refPoleInc"> 
							</td>
							<td>
								<b> Dec: </b> <input type="text" size="5" id="magDec">
								<br><b> Inc: </b> <input type="text" size="5" id="magInc"> 
							</td>
							<td>
								<b> Dec: </b> <input type="text" size="5" id="dykeDec">
								<br><b> Inc: </b> <input type="text" size="5" id="dykeInc"> 
							</td>
						</tbody>
					</table>
					<p>
					<button id="initializeNTR"> Initialize NTR Analysis </button>					
				</div>
				<p>
				<div id="NTRInputTable" style="display: none; text-align: center; margin: 0 auto; border: 1px dotted rgb(119, 152, 191);"></div>
				<div id="initialPlot" style="width: 800px; height: 800px; margin: 0 auto; display: none;"></div>
				<p>
				<div id="NTRSolutionTable" style="display: none; text-align: center; margin: 0 auto; border: 1px dotted rgb(119, 152, 191);"></div>
				<p>
				<div id="interationDiv" style="display: none; width: 600px; margin: 0 auto;">
				
				<button id="iterationButton"> Iterate over Confidence Intervals </button>
				<p>
				<input type="checkbox" id="incorrect"><label for="incorrect"> Use approach by NTR software to benchmark (incorrect approach) </label>
				<div id="iterationBar" style="width: 200px; display: inline-block;"> </div>

				<table class="sample" style="text-align: center;">
					<thead>
						<th> Reference Pole Error Inclination </th>
						<th> Magnetization Vector Error Declination / Inclination </th>
						<th> Dyke to Pole a95 </th>
					</thead>
					<tbody style="text-align: center;">
						<td> <input type="text" size="5" id="confRef"> </td>
						<td> <input type="text" size="5" id="confMagDec">
						<input type="text" size="5" id="confMagInc"> </td>
						<td> <input type="text" size="5" id="confDyke"> </td>
					</tbody>
				</table>
				</div>
				<div id="iterationPlot" style="width: 800px; height: 800px; margin: 0 auto; display: none;"></div>
			</div>
			
			<div id="optionsTab">
				Advanced Options go here
			</div>
		</div>
		<hr>
	
	<!-- FOOTER -->
	<div id="footer" class="textplot" style="margin: 10px;">
		<small> © 2015 Paleomagnetism.org. Please <a href="./cite.html">cite</a> all contributors if you use this application for your research.
		<p><b>Disclaimer:</b> Paleomagnetism.org is an open-source initiative licensed under the <a href="https://www.gnu.org/licenses/gpl.html">GNU General Public License v3.0</a>. All data processing is handled on the client-side within your browser. Graph exporting is delivered via the Highcharts content delivery network under the Highcharts <a href="http://www.highcharts.com/docs/export-module/privacy-disclaimer/">exporting privacy policy</a>.
		<hr>
		<div style="text-align: right; display: inline-block;">
			<a href="http://www.uu.nl/"><img style="margin: 0px; height: 60px;" src="./images/UU.png"></a>
			<a href="http://erc.europa.eu/"><img style="margin: 0px; height: 60px;" src="./images/ERC.png"></a>
			<a href="http://www.nwo.nl/"><img style="margin: 0px; height: 60px;" src="./images/logo NWO_plain.png"></a>
		</div>
	</div>
</div>


</BODY>

</HTML>